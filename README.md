#  基于java实现一个简单的c语言词法分析器

## 1. 实验目的

> - 学会针对DFA转换图实现相应的高级语言源程序。

> - 深刻领会状态转换图的含义，逐步理解有限自动机。

> - 掌握手工生成词法分析器的方法，了解词法分析器的内部工作原理。

## 2 .内容

> - C计算机语言的编译程序的词法分析部分实现。

> - 从左到右扫描每行该语言源程序的符号，拼成单词，换成统一的内部表示（token）送给语法分析程序。

>  为了简化程序的编写，有具体的要求如下：
>
> - 空白符仅仅是空格、回车符、制表符。
> - 代码是自由格式。
> - 注释应放在花括号之内，并且不允许嵌套

附表: c语言单词(注:下标存在错误.保留字中存在两个unsigned, 将其中一个unsigned改为signed, 特殊符号中加上!, & , |)

![image-20201101180819570](/home/fizz/.config/Typora/typora-user-images/image-20201101180819570.png)



## 3. 实验要求

>  要求实现编译器的以下功能：
>
> - 按规则拼单词,并转换成二元式形式 
> - 删除注释行 删除空白符 (空格、回车符、制表符) 显示源程序
> - 在每行的前面加上行号，并且打印出每行包含的记号的二元形式
> - 发现并定位错误。

>  词法分析进行具体的要求:
>
> - 详细给出标识符、数字、字符和字符串的状态转换图 
>
> - 画出空白间隔符的状态转换图、换行符的状态装换图、注释（//、/* */）的状态转换图。
>
> - 词法分析的具体功能实现是一个函数GetToken()，每次调用都对剩余的字符串分析得到一个单词或记号识别其种类，收集该记号的符号串属性，当识别一个单词完毕，采用返回值的形式返回符号的种类，同时采用程序变量的形式提供当前识别出记号的属性值。
>
> - 标识符和保留字的词法构成相同，为了更好的实现，把语言的保留字建立一个表格存储，这样可以把保留字的识别放在标示符之后，用识别出的标示符对比该表格，如果存在该表格中则是保留字，否则是一般标识符。

## 4. 算法分析

### 4.1  词法分析前置知识

- 什么是词法分析 

  >  词法分析就是要把源程序中的单词识别出来, 并知道这些单词所属的类别和其他的信息, 为语法分析做准备. 例如 int main() 中我们要识别出保留字 int , (, ),要识别出标识符 main.最终, 词法分析的结构用一个二元组token表示, 第一个表示词的种类编码, 第二个表示词的具体信息, 比如行号,词的值.

- 词法分析要完成的任务

  > 1. 消除无用字符
  > 2. 进行内部编码
  > 3. 建立各种表格 
  >    - 名字表: 源程序中的标识符
  >    - 常数表
  >    - 数组向量表
  >    - 界限表(保留字, 运算符登)
  >    - 进行词法检查.为了能够定位错误信息, 词法分析负责记录的新读入的字符的行号

- 词法分析的实现方式

  - 方式1

  > 1. 根据词法规则写出对应的正规式, 这很类似于词法种类的正则表达式
  > 2. 画出对应的状态转化图
  > 3. 根据状态转化图进行编码,实现单词的识别 

  - 方式2

  > 利用Lex工具自动生成

  难点: 一般而言, 采用Lex工具效率更高,使用方式一要手工构造状态转换图, 对于c语言来讲, 状态转换图过于庞大, 子程序如果没有实现很好的解耦, 代码将会冗余, 后期修改困难. 但是为了更好的理解DFA算法, 项目前期可以采用方式一.

### 4.2. 具体算法分析与设计

- 单词规则设计表
  - 二元序列<Type, Value>中, Type表示词法的种类, Value表示词法对应的具体信息
  - 具体设计规则如下表

| 状态码 | 类型        | 种类             | value                                        |
| ------ | ----------- | ---------------- | -------------------------------------------- |
| 0      | -           | 无意义           | 无意义                                       |
| 1      | ReserveWord | 保留字           | c语言保留字的值                              |
| 2      | Variable    | 标识符           | 字母或者下划线开头，其他是字母，数字，下划线 |
| 3      | Operator    | 运算符, 特殊字符 | c语言运算符                                  |
| 4      | ConstChar   | 字符常量         | 例如 'a'                                     |
| 5      | ConstStr    | 字符串常量       | 例如 "xxx"                                   |
| 6      | BInt        | 十进制非负整型   | 例如 123                                     |
| 7      | ObcInt      | 八进制非负整型   | 例如 0h123 0X123                             |
| 8      | HexInt      | 十六进制非负整型 | 例如 0x123 0X3f                              |

附 : 规则中还有很多没有加进去, 例如浮点数的识别, #include头文件的识别, 鉴于时间关系, 此时先不进行设计了.后面还可以自行进行完善.

- 状态转换图的设计 

  - 识别标识符

    ![image-20201101230737308](/home/fizz/.config/Typora/typora-user-images/image-20201101230737308.png)

  - 识别保留字

    ![image-20201101231052184](/home/fizz/.config/Typora/typora-user-images/image-20201101231052184.png)

  - 识别十进制整型, 十六进制, 八进制整型

    ![image-20201101232301082](/home/fizz/.config/Typora/typora-user-images/image-20201101232301082.png)

  - 识别常量字符

    ![image-20201101234451650](/home/fizz/.config/Typora/typora-user-images/image-20201101234451650.png)

  - 识别常量字符串

    ![image-20201101234627091](/home/fizz/.config/Typora/typora-user-images/image-20201101234627091.png)

  - 识别运算符

    ![image-20201101234108102](/home/fizz/.config/Typora/typora-user-images/image-20201101234108102.png)

  - 识别注释

  - 识别空格

    ![image-20201101234950795](/home/fizz/.config/Typora/typora-user-images/image-20201101234950795.png)

  - 识别换行符

    ![image-20201101235115684](/home/fizz/.config/Typora/typora-user-images/image-20201101235115684.png)

- 如何提升词法分析的效率

  > 课堂上老师在讲词法分析的时候, 是每读取一个字符, 进行一次识别.o操作会降低效率, 程序中我采用一次性读到内存的方式.

### 4.3. 代码架构设计与分析

-  如何解耦

  > - 如果将所有的所有的状态转换图合并在一起形成一个很大和很复杂的DFA, 再写一个函数来识别,这时代码会很长, 而且不好测试. 你只有把这个函数开发完了,才能进行测试, 明显不符合测试驱动开发的策略.
  > - 仔细分析这个识别的过程, 一个字符串识别一个词后, 接着把这个词从字符串中删除了, 进行下一次的识别. 这个一个不断迭代的过程.我们可以把问题归结为如下:
  >   1. 在字符串String中, index表示开始识别时的下标, 初始时index = 0
  >   2. 进行第一次识别后, 识别了n个字符
  >   3. 接着进行下一次识别, 开始识别的下标为index + m
  >   4. 不断迭代2,3,直到全部识别完成
  > - 有了上一步的分析, 我们可以发现, 这个问题就转换成了在一个字符串中, 根据起始字符进行识别的过程.首字符不同, 于是转向不同DFA进行识别, 这有点类似前段时间学过的策略模式.于是可以根据首字符的不同,来转向不同的DFA子程序来处理. 这样的话, 我们只需要先写好每个子程序的DFA, 例如,识别标识符的DFA, 识别保留字的DFA, 测试完成后, 通过字符串的首字符组装起来即可.

- 程序逻辑图

  ![image-20201101220525127](/home/fizz/.config/Typora/typora-user-images/image-20201101220525127.png)

  



## 5. 实验结果

### 5.1 删除注释,预处理测试

### 5.2 词法分析测试

### 5.3 源码地址: 

## 6. 实验体会

1. 最大的收获就是学习了用DFA快速处理字符串, 以前自己做有关字符串的处理时, 总是不知道如何下手.例如, 如何将字符串转换成十进制数的问题.就可以采用DFA的实现.
2. 独立完成了代码的编写, 对于java中代码解耦有了一定的认识.
3. 参考了一些资料和视频 